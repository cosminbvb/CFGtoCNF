#include "CFG.h"

#pragma region CONFIGS
void config1(CFG& x) {
    x.S = "S";
    x.N.insert("S"); x.N.insert("A"); x.N.insert("B");
    x.N.insert("C"); x.N.insert("D"); x.N.insert("F");
    x.T.insert("a"); x.T.insert("b"); x.T.insert("c");
    x.T.insert("#"); //lambda 
    x.P["S"].insert("aAb"); x.P["S"].insert("BC"); x.P["S"].insert("#");
    x.P["A"].insert("AaB"); x.P["A"].insert("Db");
    x.P["B"].insert("b"); x.P["B"].insert("c");
    x.P["C"].insert("#"); x.P["C"].insert("ab");
    x.P["D"].insert("#"); x.P["F"].insert("a");
}
void config2(CFG& x) {
    x.S = "S";
    x.N.insert("S"); x.N.insert("A"); x.N.insert("B"); x.N.insert("C");
    x.T.insert("a"); x.T.insert("b"); x.T.insert("#");
    x.P["S"].insert("A"); x.P["S"].insert("a");
    x.P["A"].insert("B"); x.P["A"].insert("b"); 
    x.P["B"].insert("#"); 
}
void config3(CFG& x) {
    x.S = "S";
    x.N.insert("S"); x.N.insert("A"); x.N.insert("B");
    x.T.insert("#"); x.T.insert("a"); x.T.insert("b");
    x.P["S"].insert("aSb"); x.P["S"].insert("aA");
    x.P["A"].insert("aA"); x.P["A"].insert("bB"); x.P["A"].insert("#");
    x.P["B"].insert("bBb");
}
void config4(CFG& x) {
    x.S = "S";
    x.N.insert("S"); x.N.insert("A"); x.N.insert("B"); x.N.insert("C");
    x.T.insert("a"); x.T.insert("b");
    x.P["S"].insert("AB"); x.P["S"].insert("CA");
    x.P["A"].insert("a"); x.P["B"].insert("BC"); x.P["B"].insert("AB");
    x.P["C"].insert("AB"); x.P["C"].insert("b");
}
void config5(CFG& x) {
    x.S = "S";
    x.T.insert("a"); x.T.insert("b"); x.T.insert("c"); x.T.insert("d");
    x.T.insert("e"); x.T.insert("f"); x.T.insert("g"); x.T.insert("#");
    x.N.insert("S"); x.N.insert("B"); x.N.insert("D"); x.N.insert("F"); 
    x.N.insert("G"); x.N.insert("H");
    x.P["S"].insert("aBcDeF"); x.P["S"].insert("HF"); x.P["S"].insert("HBc"); 
    x.P["B"].insert("b"); x.P["B"].insert("#"); x.P["D"].insert("d"); 
    x.P["D"].insert("#"); x.P["F"].insert("G"); x.P["G"].insert("f");
    x.P["G"].insert("g"); x.P["H"].insert("#");
}
#pragma endregion

CFG::CFG(const CFG& g) {
    this->N = g.N;
    this->T = g.T;
    this->S = g.S;
    this->P = g.P;
}

void CFG::printGrammar() {
    for (auto p : P) {
        cout << p.first << " -> ";
        for (auto rhs : p.second) {
            cout << rhs << " ";
        }
        cout << endl;
    }
}

void CFG::step1() {
    removeUnusable();
    removeInaccessible();
}

void CFG::step2() {
    //firsly, we need to know if lambda is generated by the grammar, directly/indirectly from S
    bool madeNewS = false;
    for (auto rhs : P[S]) {
        if (rhs == "#") {
            //if the start symbol has a lambda production
            //we make a new production S'-> S | lambda 
            //and S' becomes the new starting symbol
            string newS = "S'";
            P[S].erase("#");
            P[newS].insert(S);
            P[newS].insert("#");
            S = newS;
            madeNewS = true;
            N.insert(S);
            break;
        }
    }

    if (!madeNewS) {
        //we need to know if we can reach lambda from S indirectly, and that
        //could be done by calling step3() on a copy and check if lambda is now a production of S
        CFG copy(*this);
        copy.step3();
        bool ok = false;
        for (auto rhs : copy.P[S]) {
            if (rhs == "#") {
                ok = true;
                break;
            }
        }
        if (ok) {
            string newS = "S'";
            P[S].erase("#");
            P[newS].insert(S);
            P[newS].insert("#");
            S = newS;
            madeNewS = true;
            N.insert(S);
        }
    }
    while (hasLambda()) {
        map<string, set<string>>newP(P);
        for (auto p : newP) {
            //for each production
            for (auto rhs : p.second) {
                if (rhs == "#") {
                    if (p.second.size() == 1) {
                        //if it only has a lambda production
                        string lhs = p.first; //the lhs of the production
                        P.erase(lhs);//delete the whole production
                        //now we must remake the productions
                        //containing that non-terminal
                        for (auto p2 : P) {
                            set<string> newRHS;
                            for (auto rhs2 : p2.second) {
                                string replaceWith;
                                bool needsReplacement = false;
                                for (auto sy : rhs2) {
                                    string s;
                                    s += sy;
                                    if (s != lhs) replaceWith += sy; //this should contain the string that should substitute the old one
                                    if (s == lhs) {
                                        needsReplacement = true;
                                    }
                                }
                                if (needsReplacement) {
                                    if (rhs2.size() >= 2) {
                                        newRHS.insert(replaceWith);
                                    }
                                    if (rhs2.size() == 1) {
                                        newRHS.insert("#");
                                    }
                                }
                                else {
                                    newRHS.insert(rhs2);
                                }
                            }
                            P[p2.first] = newRHS;
                        }
                    }
                    if (p.second.size() > 1 && p.first != S) {
                        string lhs = p.first;
                        P[lhs].erase("#"); //we only delete the lambda production
                        for (auto p2 : P) {
                            set<string> newRHS;
                            for (auto rhs2 : p2.second) {
                                string replaceWith;
                                bool needsReplacement = false;
                                for (auto sy : rhs2) {
                                    string s;
                                    s += sy;
                                    if (s != lhs) replaceWith += sy; //this should contain the string that should substitute the old one
                                    if (s == lhs) {
                                        needsReplacement = true;
                                    }
                                }
                                if (needsReplacement) {
                                    newRHS.insert(rhs2);
                                    if (rhs2.size() >= 2) {
                                        newRHS.insert(replaceWith);
                                    }
                                }
                                else {
                                    newRHS.insert(rhs2);
                                }
                            }
                            P[p2.first] = newRHS;
                        }
                    }
                }
            }
        }
    }
}

void CFG::step3() {
    bool hasModified = true;
    while (hasModified) {
        hasModified = false;
        for (auto p : P) {
            set<string>newRHS;
            for (auto rhs : p.second) {
                if (N.find(rhs) != N.end()) {
                    //if we found a production of type N1->N2
                    //we must replace N2 with its productions
                    for (auto rhs2 : P[rhs]) {
                        newRHS.insert(rhs2);
                        hasModified = true;
                    }
                }
                else {
                    //if it is not of type N1->N2, we keep it
                    newRHS.insert(rhs);
                }
            }
            P[p.first] = newRHS;
        }
    }
}

void CFG::step4() {
    //we will add non-terminals of type "Xnumber" where numbers starts from 1
    for (auto p : P) {
        for (auto rhs : p.second) {

        }
    }
}

#pragma region HELPERS

set<string> CFG::usableN() {
    //eliminating unusable symbols and productions
    set<string>usable; // usable non-terminals
    for (auto p : P) {
        //for each production
        bool use = false;
        bool every = true;
        for (auto rhs : p.second) {
            //for each right hand side of the production
            //if at least one is in T* or each symbol is in T* => the non-terminal is usable
            if (T.find(rhs) != T.end()) {
                use = true;
                break;
            }
            //now we check is every symbol is in T*
            every = true;
            for (auto sy : rhs) {
                string s;
                s += sy;
                if (T.find(s) == T.end()) {//////////////
                    every = false;
                    break;
                }
            }
        }
        if (use || every) usable.insert(p.first);
    }
    bool modified = true;
    while (modified) {
        modified = false;
        for (auto p : P) {
            //for every production
            if (usable.find(p.first) == usable.end()) {
                //if the lhs was not usable before the last modification
                //we check if it is usable now
                bool every = true;
                for (auto rhs : p.second) {
                    every = true;
                    for (auto sy : rhs) {
                        string s;
                        s += sy;
                        if (T.find(s) == T.end() && usable.find(s) == usable.end()) {//////////////
                            every = false;
                            break;
                        }
                    }
                    if (every) {
                        usable.insert(p.first);
                        modified = true;
                    }
                }
            }
        }
    }
    //for (auto i : usable)cout << i << " ";
    //cout << endl;
    return usable;
}
void CFG::removeUnusable() {
    set<string>usable = usableN();
    for (auto n : N) {
        //for each non-terminal
        if (usable.find(n) == usable.end()) {
            //if it s not usable
            //we must eliminate it and any production containing it on lfs/rhs
            P.erase(n);
            for (auto p : P) {
                //for each production
                set<string> newRHS;
                for (auto rhs : p.second) {
                    //for each rhs of the production
                    bool shouldBeRemoved = false;
                    for (auto sy : rhs) {
                        string s;
                        s += sy;
                        if (s == n) {
                            //if it contains n it should be removed
                            shouldBeRemoved = true;
                            break;
                        }
                    }
                    if (!shouldBeRemoved) {
                        newRHS.insert(rhs);
                    }
                }
                P[p.first] = newRHS;
            }
        }
    }
    N = usable;
}
void CFG::removeInaccessible() {
    set<string>accessible;
    accessible.insert(S); //the start symbol is always accessible
    for (auto rhs : P[S]) {
        for (auto sy : rhs) {
            string s;
            s += sy;
            if (N.find(s) != N.end()) {
                //if we found a non-terminal in a rhs, it is accessible
                accessible.insert(s);
            }
        }
    }
    bool modified = true;
    while (modified) {
        modified = false;
        for (auto a : accessible) {
            for (auto rhs : P[a]) {
                for (auto sy : rhs) {
                    string s;
                    s += sy;
                    if (N.find(s) != N.end() && accessible.find(s) == accessible.end()) {
                        //if we found a non-terminal in a rhs and it isn t in accessible already, we add it
                        accessible.insert(s);
                        modified = true;
                    }
                }
            }
        }
    }
    for (auto n : N) {
        if (accessible.find(n) == accessible.end()) {
            //if n in inaccessible
            P.erase(n);//we remove any production with n on the lhs
        }
    }
    N = accessible;
}
bool CFG::hasLambda() {
    for (auto p : P) {
        for (auto rhs : p.second) {
            if (rhs == "#" && p.first!=S) {
                return true;
            }
        }
    }
    return false;
}

#pragma endregion